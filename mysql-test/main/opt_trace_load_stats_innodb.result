set @opt_context_schema='$opt_context_schema';
#
# In this test suite, each query is run more than once by
# using run_query_twice_and_compare_stats.inc file
#
set optimizer_record_context=ON;
set optimizer_trace=1;
set optimizer_replay_context="";
create database db1;
use db1;
#
# Range query on a single table having 1 index
#
create table t1 (c1 int, c2 int, index(c1)) engine=innodb;
insert into t1 select seq, seq from seq_1_to_10000;
analyze table t1;
Table	Op	Msg_type	Msg_text
db1.t1	analyze	status	Engine-independent statistics collected
db1.t1	analyze	status	OK
set optimizer_replay_context="";
explain format=json select * from t1 a, t1 b where a.c1 < 3 and b.c1 < 333
set @trace= (select trace from information_schema.optimizer_trace);
set @saved_opt_context=
(select json_pretty(json_extract(
json_extract(@trace, "$**.optimizer_context"),
'$[0]'
                      )
));
set @explain_output='$explain_output';
select @explain_output;
@explain_output
{
  "query_block": {
    "select_id": 1,
    "cost": 0.419766996,
    "nested_loop": [
      {
        "table": {
          "table_name": "a",
          "access_type": "range",
          "possible_keys": ["c1"],
          "key": "c1",
          "key_length": "5",
          "used_key_parts": ["c1"],
          "loops": 1,
          "rows": 2,
          "cost": 0.00606232,
          "filtered": 100,
          "index_condition": "a.c1 < 3"
        }
      },
      {
        "block-nl-join": {
          "table": {
            "table_name": "b",
            "access_type": "range",
            "possible_keys": ["c1"],
            "key": "c1",
            "key_length": "5",
            "used_key_parts": ["c1"],
            "loops": 2,
            "rows": 332,
            "cost": 0.413704676,
            "filtered": 100,
            "index_condition": "b.c1 < 333",
            "attached_condition": "b.c1 < 333"
          },
          "buffer_type": "flat",
          "buffer_size": "119",
          "join_type": "BNL"
        }
      }
    ]
  }
}
set @saved_explain_output=@explain_output;
set optimizer_replay_context="";
truncate table t1;
set optimizer_replay_context=@saved_opt_context;
set @explain_output='$explain_output';
select JSON_EQUALS(@saved_explain_output, @explain_output);
JSON_EQUALS(@saved_explain_output, @explain_output)
1
set optimizer_replay_context="";
drop table t1;
#
# Query on a single table having 2 indexes.
# 2 different ranges are specified on each index.
#
create table t1 (
c1 int,
c2 int,
index(c1),
index(c2)
) ENGINE=InnoDB;
insert into t1 select seq, seq from seq_1_to_10000;
analyze table t1;
Table	Op	Msg_type	Msg_text
db1.t1	analyze	status	Engine-independent statistics collected
db1.t1	analyze	status	OK
set optimizer_replay_context="";
explain format=json select * from t1 a, t1 b where a.c1 < 3 and b.c1 < 333 and a.c2 < 3 and b.c2 < 333
set @trace= (select trace from information_schema.optimizer_trace);
set @saved_opt_context=
(select json_pretty(json_extract(
json_extract(@trace, "$**.optimizer_context"),
'$[0]'
                      )
));
set @explain_output='$explain_output';
select @explain_output;
@explain_output
{
  "query_block": {
    "select_id": 1,
    "cost": 0.127738758,
    "nested_loop": [
      {
        "table": {
          "table_name": "a",
          "access_type": "range",
          "possible_keys": ["c1", "c2"],
          "key": "c1",
          "key_length": "5",
          "used_key_parts": ["c1"],
          "rowid_filter": {
            "range": {
              "key": "c2",
              "used_key_parts": ["c2"]
            },
            "rows": 2,
            "selectivity_pct": 0.02
          },
          "loops": 1,
          "rows": 2,
          "cost": 0.004652413,
          "filtered": 0.02,
          "index_condition": "a.c1 < 3",
          "attached_condition": "a.c2 < 3"
        }
      },
      {
        "block-nl-join": {
          "table": {
            "table_name": "b",
            "access_type": "range",
            "possible_keys": ["c1", "c2"],
            "key": "c1",
            "key_length": "5",
            "used_key_parts": ["c1"],
            "rowid_filter": {
              "range": {
                "key": "c2",
                "used_key_parts": ["c2"]
              },
              "rows": 332,
              "selectivity_pct": 3.32
            },
            "loops": 1,
            "rows": 332,
            "cost": 0.123086345,
            "filtered": 3.319999933,
            "index_condition": "b.c1 < 333",
            "attached_condition": "b.c1 < 333 and b.c2 < 333"
          },
          "buffer_type": "flat",
          "buffer_size": "119",
          "join_type": "BNL",
          "attached_condition": "b.c2 < 333"
        }
      }
    ]
  }
}
set @saved_explain_output=@explain_output;
set optimizer_replay_context="";
truncate table t1;
set optimizer_replay_context=@saved_opt_context;
set @explain_output='$explain_output';
select JSON_EQUALS(@saved_explain_output, @explain_output);
JSON_EQUALS(@saved_explain_output, @explain_output)
1
set optimizer_replay_context="";
#
# Add more data to the table and execute the query
#
insert into t1 select seq, seq from seq_1_to_20000;
analyze table t1;
Table	Op	Msg_type	Msg_text
db1.t1	analyze	status	Engine-independent statistics collected
db1.t1	analyze	status	OK
set optimizer_replay_context=@saved_opt_context;
set @explain_output='$explain_output';
select JSON_EQUALS(@saved_explain_output, @explain_output);
JSON_EQUALS(@saved_explain_output, @explain_output)
1
drop table t1;
#
# Query on a single table having 1 index.
# However, a non-constant ref access is used on the index.
#
set optimizer_replay_context="";
create table t1 (
c1 int,
c2 int,
index(c1)
) ENGINE=InnoDB;
insert into t1 select seq%100, seq%500 from seq_1_to_10000;
analyze table t1;
Table	Op	Msg_type	Msg_text
db1.t1	analyze	status	Engine-independent statistics collected
db1.t1	analyze	status	OK
set optimizer_replay_context="";
explain format=json select * from t1 as tt1, t1 as tt2 where tt1.c1 = tt2.c1
set @trace= (select trace from information_schema.optimizer_trace);
set @saved_opt_context=
(select json_pretty(json_extract(
json_extract(@trace, "$**.optimizer_context"),
'$[0]'
                      )
));
set @explain_output='$explain_output';
select @explain_output;
@explain_output
{
  "query_block": {
    "select_id": 1,
    "cost": 1003.395568,
    "nested_loop": [
      {
        "table": {
          "table_name": "tt1",
          "access_type": "ALL",
          "possible_keys": ["c1"],
          "loops": 1,
          "rows": 10000,
          "cost": 1.6605152,
          "filtered": 100,
          "attached_condition": "tt1.c1 is not null"
        }
      },
      {
        "table": {
          "table_name": "tt2",
          "access_type": "ref",
          "possible_keys": ["c1"],
          "key": "c1",
          "key_length": "5",
          "used_key_parts": ["c1"],
          "ref": ["db1.tt1.c1"],
          "loops": 10000,
          "rows": 100,
          "cost": 1001.735053,
          "filtered": 100
        }
      }
    ]
  }
}
set @saved_explain_output=@explain_output;
set optimizer_replay_context="";
truncate table t1;
set optimizer_replay_context=@saved_opt_context;
set @explain_output='$explain_output';
select JSON_EQUALS(@saved_explain_output, @explain_output);
JSON_EQUALS(@saved_explain_output, @explain_output)
1
set optimizer_replay_context="";
#
# On the same table, test with non-constant ref access with out using an index
# Also, re-insert data
#
insert into t1 select seq%100, seq%500 from seq_1_to_10000;
analyze table t1;
Table	Op	Msg_type	Msg_text
db1.t1	analyze	status	Engine-independent statistics collected
db1.t1	analyze	status	OK
set optimizer_replay_context="";
explain format=json select * from t1 as tt1, t1 as tt2 where tt1.c2 = tt2.c2 and tt1.c2 <= 100
set @trace= (select trace from information_schema.optimizer_trace);
set @saved_opt_context=
(select json_pretty(json_extract(
json_extract(@trace, "$**.optimizer_context"),
'$[0]'
                      )
));
set @explain_output='$explain_output';
select @explain_output;
@explain_output
{
  "query_block": {
    "select_id": 1,
    "cost": 374.9067624,
    "nested_loop": [
      {
        "table": {
          "table_name": "tt1",
          "access_type": "ALL",
          "loops": 1,
          "rows": 10000,
          "cost": 1.6605152,
          "filtered": 20,
          "attached_condition": "tt1.c2 <= 100"
        }
      },
      {
        "block-nl-join": {
          "table": {
            "table_name": "tt2",
            "access_type": "ALL",
            "loops": 2000,
            "rows": 10000,
            "cost": 373.2462472,
            "filtered": 20
          },
          "buffer_type": "flat",
          "buffer_size": "21Kb",
          "join_type": "BNL",
          "attached_condition": "tt2.c2 = tt1.c2"
        }
      }
    ]
  }
}
set @saved_explain_output=@explain_output;
set optimizer_replay_context="";
truncate table t1;
set optimizer_replay_context=@saved_opt_context;
set @explain_output='$explain_output';
select JSON_EQUALS(@saved_explain_output, @explain_output);
JSON_EQUALS(@saved_explain_output, @explain_output)
1
set optimizer_replay_context="";
drop table t1;
#
# Query on a single table having 1 index.
# However, a constant eq_ref access is used on the index.
#
set optimizer_replay_context="";
create table t1 (
c1 int,
c2 int,
index(c1)
) ENGINE=InnoDB;
insert into t1 select seq%100, seq%500 from seq_1_to_10000;
analyze table t1;
Table	Op	Msg_type	Msg_text
db1.t1	analyze	status	Engine-independent statistics collected
db1.t1	analyze	status	OK
set optimizer_replay_context="";
explain format=json select * from t1 as tt1 where tt1.c1 = 5
set @trace= (select trace from information_schema.optimizer_trace);
set @saved_opt_context=
(select json_pretty(json_extract(
json_extract(@trace, "$**.optimizer_context"),
'$[0]'
                      )
));
set @explain_output='$explain_output';
select @explain_output;
@explain_output
{
  "query_block": {
    "select_id": 1,
    "cost": 0.12065072,
    "nested_loop": [
      {
        "table": {
          "table_name": "tt1",
          "access_type": "ref",
          "possible_keys": ["c1"],
          "key": "c1",
          "key_length": "5",
          "used_key_parts": ["c1"],
          "ref": ["const"],
          "loops": 1,
          "rows": 100,
          "cost": 0.12065072,
          "filtered": 100
        }
      }
    ]
  }
}
set @saved_explain_output=@explain_output;
set optimizer_replay_context="";
truncate table t1;
set optimizer_replay_context=@saved_opt_context;
set @explain_output='$explain_output';
select JSON_EQUALS(@saved_explain_output, @explain_output);
JSON_EQUALS(@saved_explain_output, @explain_output)
1
set optimizer_replay_context="";
#
# On the same table as above, test with constant ref access with out using an index
# Also, re-insert data
#
insert into t1 select seq%100, seq%500 from seq_1_to_10000;
analyze table t1;
Table	Op	Msg_type	Msg_text
db1.t1	analyze	status	Engine-independent statistics collected
db1.t1	analyze	status	OK
set optimizer_replay_context="";
explain format=json select * from t1 as tt1 where tt1.c2 = 5
set @trace= (select trace from information_schema.optimizer_trace);
set @saved_opt_context=
(select json_pretty(json_extract(
json_extract(@trace, "$**.optimizer_context"),
'$[0]'
                      )
));
set @explain_output='$explain_output';
select @explain_output;
@explain_output
{
  "query_block": {
    "select_id": 1,
    "cost": 1.6605152,
    "nested_loop": [
      {
        "table": {
          "table_name": "tt1",
          "access_type": "ALL",
          "loops": 1,
          "rows": 10000,
          "cost": 1.6605152,
          "filtered": 0.200000003,
          "attached_condition": "tt1.c2 = 5"
        }
      }
    ]
  }
}
set @saved_explain_output=@explain_output;
set optimizer_replay_context="";
truncate table t1;
set optimizer_replay_context=@saved_opt_context;
set @explain_output='$explain_output';
select JSON_EQUALS(@saved_explain_output, @explain_output);
JSON_EQUALS(@saved_explain_output, @explain_output)
1
set optimizer_replay_context="";
drop table t1;
drop database db1;
